/*
    注意 ：二进制数从右边第 0 位开始

左移运算符( << ) 一个整数为8个位 ，1个字节8个位
    左移运算符是用来将一个数的各二进制位全部左移若干位
    例如 ：a = <<2 将 a 的二进制数向左移2位，右边补 0 
    a = 15 (二进制'0000 1111') 左移2位得 '0011 1100' (十进制数60，相当于a * 2的n次方，n为移的位数)
    即 a 左移2位得到的十进制数为 60 = 15 * 2 * 2 ，如果高位溢出部分包括'1'则不成立
若高位左移后溢出，则舍弃溢出部分


右移运算符( >> )
    左移运算符是用来将一个数的各二进制位全部右移若干位，移到右边的低位被舍弃，对无符号数，高位补0
    例如 ：a = >> 2 将 a 的二进制数向右移2位 
    a = 15 (二进制'0000 1111') 右移2位得 '0000 0011' (十进制数3，相当于a / 2的n次方，n为移的位数)
    右移1位相当于除于 2 ，右移n位相当于除于 2^n
1. 对于无符号数，右移时左边高位补0
2. 对于有符号的数，如果原来符号位为 0 (该数为正)，则左边也移入 0 
3. 如果原来符号位为 1 (该数为负)，取决于所用的计算机系统，有的系统移入 0，有的移入 1 
    移入 0 的称为 “逻辑右移” ，即简单右移。移入 1 的称为 “算术右移”
例如 ：a 的值是十进制 -2 (二进制'1111 1110')
      无符号数 ：a >> 1 : 0111 1111 (逻辑右移时)
      有符号数 ：a >> 1 : 1111 1111 (算术右移时) (十进制数为 -1)

{

	auto i = 11;		//2进制: 0000 1011 , 10进制:11
	 i = i << 1;		//左移1位
	 std::cout << i;	//2进制: 0001 0110 , 10进制:22
	 i = i << 1;		//继续左移1位
	 std::cout << i;	//2进制: 0010 1100 , 10进制:44

	 auto i2 = 11;	
	 i2 = i2 >> 1;		//右移
	 std::cout << i2;	//2进制: 0000 0101 , 10进制:5
	 i2 = i2 >> 1;		//继续右移一位
	 std::cout << i2;	//2进制: 0000 0010 , 10进制:2
}
*/

#include <stdio.h>

void main()
{
/***************************无符号位********************************************/
    unsigned char a = -2 ;  // 定义为无符号型 (二进制'1111 1110')

    a = a >> 1 ; // 逻辑右移1位 --> ('0111 1111' 十进制为127) 无符号型右移后左边补 0

    printf ("a = %d\n" , a) ;  // 输出127



/****************************有符号位*****************************************/

// 对于有符号位的数，如果第一位符号位为 0 ，该数为正 ，如果为1，该数为负
/*  1. 对于负数的二进制数，先求出该数绝对数的原码，第一位数为1(代表负号) ，再根据原码求出反码，
       在反码的基础上 "+1",得到补码，即该负数的二进制数  
例如 ：-2 ， 2的原码为 '0000 0010' , 反码为 '1111 1101' , 补码为 '1111 1110',则为 -2的二进制数
     
    2. 对于正数的原码和补码一样                                                               */

    signed char b = -2 ;  // 定义为有符号型 (二进制'1111 1110')
    unsigned char c ;     

    b = b >> 1 ; // 算术右移1位 --> '1111 1111' (十进制为 -1) 无符号型右移后左边补 1
    c = b ;

    printf ("b = %d\n" , b) ;  // 输出 -1
    printf ("c = %d\n" , c) ;  // 输出255 ，c为无符号数，直接读取'1111 1111'

    
}