/*
题目：
    有一行电文，以按下面规律译成密码：
        A--->Z   a--->z
        B--->Y   b--->Y
        C--->X   c--->x
        ……
    即第1个字母编程第26个字母，第i个字母编程第(26-i+1)个字母，非字母字符不变，
    要求编程序将密码译回原文，并输出密码和原文。
【答案解析】
    从题目给的实例中可以看到，编码规则非常简单，就是将从前往后数的第i个字母转化为从后往前数的第i个字母。
    那解压时直接反过来转换即可：
        即’Z’—>‘A’ ‘z’—>‘a’
        ​  ‘Y’—>‘B’ ‘y’—>‘b’
        ​  ‘X’—>‘C’ ‘x’—>‘c’
    假设如果当前拿到的是小写字母，转换方式如下：
        1. 先用s[i] - 'a’计算出s[i]是26个字母中从前往后数的第几个
        2. 再用26 - (s[i]- ‘a’) - 1 转换为26个字母中从后往前数的第几个
        3. 在2的结果上加上’a’，即转换为对应从后往前的第几个字母
    大写字母转换方式与上述相同，将上述每条中的’a’换为‘A’即可。
*/

#include <stdio.h>
#include <string.h>

int main()
{
    char s[1024] = {0};
    printf("Please enter your password:") ;  //请输入密码
    scanf("%s", s);
    printf("The password is:%s\n", s); // 输出密码

    // strlen 字符串长度 ，返回s指向的字符串长度，不包括空字符。
    // 可通过 man strlen命令来查看此函数的表达式和头文件。
    int len = strlen(s);
    // 转换
    for (int i = 0; i < len; ++i)
    {
        // 如果是小写字母(大写字母出来类似)：
        // 1. 先用s[i] - 'a'计算出s[i]是26个字母中从前往后数的第几个
        // 2. 再用26 - (s[i]- 'a') - 1 转换为26个字母中从后往前数的第几个
        // 3. 在2的结果上加上'a'，即转换为对应从后往前的第几个字母
        if (s[i] >= 'a' && s[i] <= 'z')
            s[i] = 'a' + 26 - (s[i] - 'a') - 1;
        else if (s[i] >= 'A' && s[i] <= 'Z')
            s[i] = 'A' + 26 - (s[i] - 'A') - 1;
    }

    printf("The original is:%s\n", s); //输出原文
    return 0;
}
